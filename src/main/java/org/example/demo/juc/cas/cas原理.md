# CAS原理
CAS需要3个值：主内存中的新值v，主内存中旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B。 

通俗来说，就是每一个线程从主内存复制一个变量副本后，进行操作，然后对其进行修改，修改完后，再刷新回主内存前。再取一次主内存的值，看拿到的主内存的新值与

当初保存的快照值，是否一样，如果不一样，说明有其他线程修改，本次修改放弃，重试  

# CAS相对Java锁的好处
避免线程阻塞，导致的线程上下文切换，影响系统开销

# ABA问题
ABA问题的根本在于cas在修改变量的时候，无法记录变量的状态，比如修改的次数，是否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A

**ABA解决方案**

利用AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验  

通过添加一个stamp字段，在更新数据后，刷新到主内存之前，会先判断stamp的期待值和内存中的值是否相同，如果不同，说明内存中的共享变量值已经被修改过了，即修改失败  



# CAS场景
1、juc包下的atomic包就是使用了cas + volatile来保证线程安全的

2、乐观锁

比如数据库中的乐观锁，通过版本号实现  

